import { EventEmitter, Component, ViewEncapsulation, forwardRef, ViewChild, Input, Output, HostListener, Directive, ElementRef, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { isSameDay, isSameMonth, isSameYear, getDate, getMonth, getYear, isToday, startOfMonth, isAfter, isBefore, format, endOfMonth, eachDayOfInterval, getDay, subDays, addDays, setDay, setMonth, addMonths, subMonths, setYear } from 'date-fns';
import { CommonModule } from '@angular/common';

const isSameDate = (date, current) => (isSameDay(date, current) && isSameMonth(date, current) && isSameYear(date, current));

const createDateRange = (start, end) => ({
    start: start ? new Date(start.getTime()) : null,
    end: end ? new Date(end.getTime()) : null,
});

/**
 * Internal library helper that helps to check if value is empty
 */
const isNull = (value) => {
    return (typeof value === 'undefined') || (value === null);
};

// instanceID for calculating the auto-incrementing field ID
let instanceID = 0;
class NgxDatePickerComponent {
    constructor() {
        /**
         * Set date picker's visibility state
         */
        this.isOpened = true;
        this.valueChange = new EventEmitter();
        this.currentOptions = {
            closeOnClickOutside: false,
            closeOnSelection: true,
            includeDays: 'all',
            includeNextMonthsFirstFullWeek: false,
            minYear: 1900,
            maxYear: 2050,
            displayFormat: 'MMM d, yyyy',
            barTitleFormat: 'MMM yyyy',
            dayNamesFormat: 'EEEEEE',
            rangeSeparator: '-',
            selectRange: false,
            firstCalendarDay: 0,
            barTitleIfEmpty: 'Click to select a date',
            locale: {},
            fieldId: this.defaultFieldId,
            useEmptyBarTitle: true,
            mobileStyle: 'dialog'
        };
        this.onTouchedCallback = () => { };
        this.onChangeCallback = (_) => {
            this.valueChange.emit(_);
        };
        this.formatDay = (date, isVisible = true) => ({
            date,
            day: getDate(date),
            month: getMonth(date),
            year: getYear(date),
            inThisMonth: isSameMonth(date, this.viewingDate),
            isToday: isVisible && isToday(date),
            isSelected: isVisible && this.isDateSelected(date),
            isInRange: isVisible && this.isInRange(date),
            isSelectable: isVisible && this.isDateSelectable(date),
            isStart: isVisible && this.isRangeBoundary(date, 'start'),
            isEnd: isVisible && this.isRangeBoundary(date, 'end'),
            isVisible,
        });
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    set range(val) {
        this._range = val;
    }
    get range() {
        return this._range;
    }
    get wrapperStyle() {
        switch (this.currentOptions.mobileStyle) {
            case 'dialog':
                return this.isInline === false ? 'form-date' : 'inline-date';
            case 'normal':
            default:
                return '';
        }
    }
    ngOnInit() {
        if (typeof startOfMonth === 'undefined') {
            throw new Error('module date-fns is required by <ngx-date-picker> to function.');
        }
        this.view = 'days';
        this.range = this.range || {
            start: new Date(),
            end: new Date(),
        };
        if (this.value && !(this.value instanceof Date)) {
            this.range = this.value;
            this.viewingDate = this.range.start;
        }
        else if (this.value && this.value instanceof Date) {
            this.viewingDate = this.value;
        }
        else {
            this.viewingDate = this.range.start;
        }
        this.updateOptions(this.options);
        this.initDayNames();
        this.initYears();
        this.initMonths();
        this.init();
    }
    ngOnChanges(changes) {
        if ('options' in changes) {
            this.updateOptions(changes.options.currentValue);
            this.initDayNames();
            this.init();
            this.initYears();
            this.initMonths();
        }
    }
    get defaultFieldId() {
        // Only evaluate and increment if required
        const value = `ngx-date-picker-${instanceID++}`;
        Object.defineProperty(this, 'defaultFieldId', { value });
        return value;
    }
    updateOptions(options) {
        this.currentOptions = Object.assign(Object.assign({}, this.currentOptions), options);
    }
    writeValue(val) {
        if (val) {
            if (typeof val === 'string') {
                this.range.start = this.range.end = new Date(val);
            }
            else if (val instanceof Date) {
                this.range.start = this.range.end = val;
            }
            else if (val.start) { // Checking if it's instance of DateRange
                this.range = val;
            }
            else {
                throw Error('Invalid input data type');
            }
            this.viewingDate = this.range.start || this.viewingDate || new Date();
            this.init();
        }
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    getDayClasses(day) {
        return {
            'is-prev-month': !day.inThisMonth,
            'is-today': day.isToday,
            'is-selected': day.isSelected,
            'is-in-range': day.isInRange,
            'is-disabled': !day.isSelectable,
            'range-start': day.isStart,
            'range-end': day.isEnd,
            'is-visible': day.isVisible,
        };
    }
    /**
     * Checks if specified date is in range of min and max dates
     */
    isDateSelectable(date) {
        const minDateSet = !isNull(this.currentOptions.minDate);
        const maxDateSet = !isNull(this.currentOptions.maxDate);
        const timestamp = date.valueOf();
        // Check if the date range is set and between min and max
        const _isAboveMinDate = minDateSet ? timestamp >= this.currentOptions.minDate.valueOf() : true;
        const _isBelowMaxDate = maxDateSet ? timestamp <= this.currentOptions.maxDate.valueOf() : true;
        return _isAboveMinDate && _isBelowMaxDate;
    }
    isDateSelected(date) {
        return this.range && this.range.start ? isSameDate(date, this.range.start) || isSameDate(date, this.range.end) : false;
    }
    isInRange(date) {
        return this.isDateSelected(date) || this.range && this.range.start ? (isAfter(date, this.range.start) && isBefore(date, this.range.end)) : false;
    }
    formatDisplay() {
        if (!this.range) {
            return '';
        }
        const formattedStartDate = format(this.range.start, this.currentOptions.displayFormat, this.currentOptions.locale);
        if (this.currentOptions.selectRange) {
            const formattedEndDate = format(this.range.end || this.range.start, this.currentOptions.displayFormat, this.currentOptions.locale);
            return `${formattedStartDate} ${this.currentOptions.rangeSeparator} ${formattedEndDate}`;
        }
        return formattedStartDate;
    }
    isRangeBoundary(date, boundary) {
        return this.range ? !this.range[boundary] || isSameDate(date, this.range[boundary]) : false;
    }
    getValueToEmit(range) {
        if (!range || !range.start) {
            return null;
        }
        if (!this.currentOptions.selectRange) {
            return new Date(range.start.getTime());
        }
        if (range.end) {
            return createDateRange(range.start, range.end);
        }
        return createDateRange(range.start, range.start);
    }
    // ############### Day #################
    init() {
        if (!this.viewingDate) {
            return;
        }
        const start = startOfMonth(this.viewingDate);
        const end = endOfMonth(this.viewingDate);
        this.days = eachDayOfInterval({ start, end }).map((date) => this.formatDay(date));
        const firstMonthDay = getDay(start) - this.currentOptions.firstCalendarDay;
        const prevDays = firstMonthDay < 0 ? 7 - this.currentOptions.firstCalendarDay : firstMonthDay;
        let nextDays = (this.currentOptions.firstCalendarDay === 1 ? 7 : 6) - getDay(end);
        const showPrevMonthDays = this.currentOptions.includeDays === 'all' || this.currentOptions.includeDays === 'previous-month';
        const showNextMonthDays = this.currentOptions.includeDays === 'all' || this.currentOptions.includeDays === 'next-month';
        if (showNextMonthDays && this.currentOptions.includeNextMonthsFirstFullWeek) {
            nextDays += 7;
        }
        for (let i = 1; i <= prevDays; i++) {
            this.days.unshift(this.formatDay(subDays(start, i), showPrevMonthDays));
        }
        new Array(nextDays).fill(undefined)
            .forEach((_, i) => this.days.push(this.formatDay(addDays(end, i + 1), showNextMonthDays)));
        this.displayValue = this.formatDisplay();
        if (this.range) {
            this.barTitle = format(this.viewingDate, this.currentOptions.barTitleFormat, this.currentOptions.locale);
        }
        else {
            this.barTitle = this.currentOptions.useEmptyBarTitle ?
                this.currentOptions.barTitleIfEmpty :
                format(this.viewingDate, this.currentOptions.barTitleFormat, this.currentOptions.locale);
        }
    }
    setDate(i) {
        const date = this.days[i].date;
        const _range = this.range || {};
        if (this.currentOptions.selectRange) {
            if (!this.range || (!this.range.start && !this.range.end)) {
                _range.start = date;
            }
            else if (this.range.start && !this.range.end && isAfter(date, this.range.start)) {
                _range.end = date;
            }
            else {
                _range.end = undefined;
                _range.start = date;
            }
        }
        else {
            _range.start = _range.end = date;
        }
        this.range = _range;
        this.init();
        this.onChangeCallback(this.getValueToEmit(this.range));
        // Close if last value is selected
        if (this.currentOptions.closeOnSelection && this.range.end) {
            this.close();
        }
    }
    initDayNames() {
        this.dayNames = [];
        const start = this.currentOptions.firstCalendarDay;
        for (let i = start; i <= 6 + start; i++) {
            const date = setDay(new Date(), i);
            this.dayNames.push(format(date, this.currentOptions.dayNamesFormat, this.currentOptions.locale));
        }
    }
    // ############### Month ###############
    setMonth(i) {
        this.viewingDate = setMonth(this.viewingDate, this.months[i].month);
        this.init();
        this.initMonths();
        this.view = 'days';
    }
    initMonths() {
        this.months = Array.from(new Array(12), (x, i) => setMonth(new Date(), i))
            .map((date) => {
            return { month: date.getMonth(), name: format(date, 'MMM'), isSelected: date.getMonth() === getMonth(this.viewingDate) };
        });
    }
    nextMonth() {
        this.viewingDate = addMonths(this.viewingDate, 1);
        this.init();
    }
    prevMonth() {
        this.viewingDate = subMonths(this.viewingDate, 1);
        this.init();
    }
    // ############### Year ################
    initYears() {
        const range = this.currentOptions.maxYear - this.currentOptions.minYear;
        /* tslint:disable */
        // Ignore the rule due to the uniqeness of the arrow chain.
        this.years = Array.from(new Array(range), (x, i) => { return { index: i, year: i + this.currentOptions.minYear }; }).map(({ index, year }) => {
            return { index: index, year: year, isThisYear: year === getYear(this.viewingDate) };
        });
        /* tslint:enable */
    }
    scrollYears() {
        setTimeout(() => {
            const _heightOfYearElement = 40;
            const _yearIndex = this.years.filter(item => item.isThisYear)[0];
            const _scrollPosition = ((_yearIndex.index / 3) * _heightOfYearElement) - 30;
            this.calendarYearsContainer.nativeElement.scroll(0, _scrollPosition);
        }, 100);
    }
    setYear(i) {
        this.viewingDate = setYear(this.viewingDate, this.years[i].year);
        this.init();
        this.initYears();
        this.view = 'months';
    }
    // ############### Container ################
    toggleView() {
        this.view = this.view === 'days' ? 'years' : 'days';
        this.scrollYears();
    }
    toggle() {
        this.isOpened = !this.isOpened;
        if (!this.isOpened && this.view === 'years') {
            this.toggleView();
        }
        if (this.isOpened && this.view === 'days') {
            this.viewingDate = this.range && this.range.start ? this.range.start : this.viewingDate || new Date();
            this.init();
        }
    }
    reset() {
        this.range = {
            start: new Date(),
            end: new Date(),
        };
        this.init();
    }
    // ############### Misc ################
    onBlur(e) {
        if (!this.isOpened || !this.currentOptions.closeOnClickOutside) {
            return;
        }
        if ((e.target.parentElement && e.target.parentElement.classList.contains('day-unit'))) {
            return;
        }
        if (this.calendarContainerElement.nativeElement !== e.target &&
            !this.calendarContainerElement.nativeElement.contains(e.target) &&
            !e.target.classList.contains('year-unit') &&
            !e.target.classList.contains('month-unit')) {
            this.close();
        }
    }
    close() {
        this.isOpened = false;
        if (this.view === 'years') {
            this.toggleView();
        }
    }
}
NgxDatePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-date-picker',
                template: "<div *ngIf=\"isOpened\" class=\"ngx-date-picker-calendar-wrapper {{wrapperStyle}}\">\r\n\r\n  <div #container class=\"ngx-date-picker-calendar-container\">\r\n\r\n    <!-- Top Bar -->\r\n    <div class=\"ngx-date-picker-navbar\">\r\n\r\n      <div class=\"ngx-date-picker-navbar-item\" (click)=\"prevMonth()\">\r\n        <i class=\"arrow left\"></i>\r\n      </div>\r\n\r\n      <span class=\"ngx-date-picker-title\" (click)=\"toggleView()\">{{ barTitle }}</span>\r\n\r\n      <div class=\"ngx-date-picker-navbar-item\" (click)=\"nextMonth()\">\r\n        <i class=\"arrow right\"></i>\r\n      </div>\r\n\r\n    </div>\r\n\r\n    <div class=\"main-calendar-container\">\r\n\r\n      <!-- Days -->\r\n      <div [ngClass]=\"{ 'show': view === 'days', 'hidden': view !== 'days' }\">\r\n        <div class=\"main-calendar-day-names\">\r\n          <span class=\"day-name-unit\" *ngFor=\"let name of dayNames\">{{ name }}</span>\r\n        </div>\r\n        <div class=\"main-calendar-days\">\r\n          <span class=\"day-unit\" *ngFor=\"let day of days; let i = index;\" (click)=\"day.isSelectable && setDate(i)\">\r\n            <span class=\"day-background-upper\"\r\n              [ngClass]=\"this.getDayClasses(day)\">{{ day.isVisible ? day.day : '' }}</span>\r\n          </span>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Months -->\r\n      <div [ngClass]=\"{ 'show': view === 'months', 'hidden': view !== 'months' }\">\r\n        <div class=\"main-calendar-months\">\r\n          <span *ngFor=\"let month of months; let i = index;\" class=\"month-unit\"\r\n            [ngClass]=\"{ 'is-selected': month.isSelected}\" (click)=\"setMonth(i)\">\r\n            {{ month.name }}\r\n          </span>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Years -->\r\n      <div [ngClass]=\"{ 'show': view === 'years', 'hidden': view !== 'years' }\">\r\n        <div #calendarYearsContainer class=\"main-calendar-years\">\r\n          <span *ngFor=\"let year of years; let i = index;\" class=\"year-unit\"\r\n            [ngClass]=\"{ 'is-selected': year.isThisYear }\" (click)=\"setYear(i)\">\r\n            {{ year.year }}\r\n          </span>\r\n        </div>\r\n      </div>\r\n\r\n    </div>\r\n\r\n  </div>\r\n</div>",
                encapsulation: ViewEncapsulation.None,
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NgxDatePickerComponent), multi: true }
                ],
                styles: [".ngx-date-picker-calendar-container{background:#fff;border:1px solid #dfe3e9;border-radius:4px;box-shadow:0 10px 14px 10px rgba(0,0,0,.08);max-width:100vw;position:absolute;width:300px;z-index:100}@media (max-width:768px){.ngx-date-picker-calendar-wrapper.form-date{background:hsla(0,0%,78.4%,.5);height:100vh;left:0;position:fixed;top:0;width:100vw;z-index:9999}.ngx-date-picker-calendar-wrapper.form-date .ngx-date-picker-calendar-container{left:50%;max-width:100vw;top:50%;transform:translate(-50%,-50%);width:90vw}.ngx-date-picker-calendar-wrapper.form-date .ngx-date-picker-title{font-size:1rem}.ngx-date-picker-calendar-wrapper.form-date .day-unit,.ngx-date-picker-calendar-wrapper.form-date .month-unit,.ngx-date-picker-calendar-wrapper.form-date .year-unit{font-size:1rem;height:2rem}}.ngx-date-picker-navbar{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;align-items:center;border-bottom:1px solid #dfe3e9;display:flex;height:50px;justify-content:space-between;user-select:none}.ngx-date-picker-navbar .ngx-date-picker-navbar-item{cursor:pointer;padding:16px}.ngx-date-picker-navbar .ngx-date-picker-navbar-item .arrow{border:solid #000;border-width:0 3px 3px 0;display:inline-block;padding:3px}.ngx-date-picker-navbar .ngx-date-picker-navbar-item .arrow.right{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}.ngx-date-picker-navbar .ngx-date-picker-navbar-item .arrow.left{-webkit-transform:rotate(135deg);transform:rotate(135deg)}.ngx-date-picker-title{color:#3d495c;cursor:pointer;font-size:14px;font-weight:600}.main-calendar-container{box-sizing:border-box;font-size:12px;font-weight:500;height:100%;padding:15px 10px;width:100%}.main-calendar-container .show{display:block}.main-calendar-container .hidden{display:none}.main-calendar-day-names{align-items:center;box-sizing:border-box;color:#cbcbcb;display:flex;width:100%}.day-name-unit{margin:5px 5px 0 0;text-align:center;text-transform:uppercase;width:14.28571%}.main-calendar-days{overflow:hidden}.main-calendar-days,.main-calendar-years{display:inline-block;padding:15px 0 0;width:100%}.main-calendar-years{overflow-x:hidden;overflow-y:scroll}.main-calendar-years::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);background-color:#f5f5f5}.main-calendar-years::-webkit-scrollbar{background-color:#f5f5f5;width:6px}.main-calendar-years::-webkit-scrollbar-thumb{background-color:#000}.day-unit,.month-unit,.year-unit{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;cursor:pointer;float:left;font-size:14px;font-weight:400;height:35px;margin:5px 5px 0 0;position:relative;user-select:none;width:calc(14.28571% - 5px)}.day-background-upper,.day-unit,.month-unit,.year-unit{align-items:center;display:inline-flex;justify-content:center}.day-background-upper{background:#f0f0f0;border-radius:4px;color:#333;height:100%;position:absolute;width:100%;z-index:1}.day-background-upper:not(.is-visible){cursor:default}.day-background-upper:hover{background:rgba(255,0,0,.6);color:#f0f0f0}.day-background-upper.is-prev-month{color:#cbcbcb}.day-background-upper.is-prev-month:hover{background:rgba(255,0,0,.6);color:#f0f0f0}.day-background-upper.is-disabled{color:#cbcbcb;cursor:not-allowed}.day-background-upper.is-in-range{background:rgba(255,0,0,.6);color:#f0f0f0}.day-background-upper.is-selected{background:red;color:#f0f0f0}.main-calendar-years{display:block;height:210px;padding:0}.month-unit{height:54px;width:calc(25% - 5px)}.year-unit{width:calc(33.33333% - 5px)}.month-unit,.year-unit{border-radius:4px}.month-unit.is-selected,.year-unit.is-selected{background:red;color:#f0f0f0}.month-unit:hover,.year-unit:hover{background:rgba(255,0,0,.6);color:#f0f0f0}.main-calendar-months{display:inline-block;padding-bottom:10px}"]
            },] }
];
NgxDatePickerComponent.propDecorators = {
    calendarContainerElement: [{ type: ViewChild, args: ['container',] }],
    calendarYearsContainer: [{ type: ViewChild, args: ['calendarYearsContainer',] }],
    value: [{ type: Input }],
    options: [{ type: Input }],
    isOpened: [{ type: Input }],
    valueChange: [{ type: Output }],
    onBlur: [{ type: HostListener, args: ['document:click', ['$event'],] }]
};

class NgxDatePickerDirective {
    constructor(_el) {
        this._el = _el;
        this.valueChange = new EventEmitter();
        this.onChange = (_value) => { };
        this.onTouched = () => { };
    }
    ngOnInit() {
        if (!this.datePickerInstance) {
            throw new Error('Instance of <ngx-date-picker> is required for directive.');
        }
        this.datePickerInstance.isOpened = false;
        this.datePickerInstance.isInline = false;
        // this.datePickerInstance.currentOptions.closeOnSelection = true;
        this.datePickerInstance.currentOptions.closeOnClickOutside = false;
        this.onChangeSubscription = this.datePickerInstance.valueChange.subscribe((value) => {
            this._el.nativeElement.value = this.datePickerInstance.formatDisplay();
            this.valueChange.emit(value);
            this.onChange(value);
        });
    }
    ngAfterViewInit() {
        if (!this.value) {
            return;
        }
        if (this.value instanceof Date) {
            this.datePickerInstance.range = createDateRange(this.value, this.value);
        }
        else {
            this.datePickerInstance.range = this.value;
        }
        this.datePickerInstance.valueChange.emit(this.datePickerInstance.getValueToEmit(this.datePickerInstance.range));
    }
    ngOnDestroy() {
        if (this.onChangeSubscription) {
            this.onChangeSubscription.unsubscribe();
        }
    }
    // ############# ControlValueAccessor #############
    writeValue(value) {
        if (value instanceof Date) {
            this.datePickerInstance.range = createDateRange(value, value);
        }
        else {
            this.datePickerInstance.range = value;
        }
        this.datePickerInstance.valueChange.emit(this.datePickerInstance.getValueToEmit(this.datePickerInstance.range));
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.datePickerInstance.disabled = isDisabled;
    }
    // ############# Click Events #############
    onClick(e) {
        this.datePickerInstance.toggle();
    }
    onBlur(e) {
        if (!this.datePickerInstance.isOpened) {
            return;
        }
        if ((e.target.parentElement && e.target.parentElement.classList.contains('day-unit'))) {
            return;
        }
        if (this._el.nativeElement !== e.target &&
            !this.datePickerInstance.calendarContainerElement.nativeElement.contains(e.target) &&
            !e.target.classList.contains('year-unit') &&
            !e.target.classList.contains('month-unit')) {
            this.datePickerInstance.close();
        }
    }
}
NgxDatePickerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngxDatePicker]',
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NgxDatePickerDirective), multi: true }
                ]
            },] }
];
NgxDatePickerDirective.ctorParameters = () => [
    { type: ElementRef }
];
NgxDatePickerDirective.propDecorators = {
    datePickerInstance: [{ type: Input, args: ['ngxDatePicker',] }],
    value: [{ type: Input }],
    valueChange: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onBlur: [{ type: HostListener, args: ['document:click', ['$event'],] }]
};

class NgxDatePickerModule {
}
NgxDatePickerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NgxDatePickerComponent, NgxDatePickerDirective],
                imports: [CommonModule, FormsModule],
                exports: [NgxDatePickerComponent, NgxDatePickerDirective, CommonModule, FormsModule]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { NgxDatePickerComponent, NgxDatePickerModule, NgxDatePickerDirective as ɵa };
//# sourceMappingURL=ngx-tiny-date-picker.js.map
